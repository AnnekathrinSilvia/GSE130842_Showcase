---
title: >
  Enhancing analysis and interpretation workflows for transcriptome data with an interactive R/Bioconductor toolkit
author:
- name: Annekathrin Silvia Nedwed
  affiliation: 
  - &id1 Institute of Medical Biostatistics, Epidemiology and Informatics (IMBEI), Mainz<br>
  email: anneludt@uni-mainz.de
date: "`r BiocStyle::doc_date()`"
package: "`r BiocStyle::pkg_ver('GeDi')`"
output: 
  bookdown::html_document2:
    toc: true
    toc_float: true
    theme: cosmo
    code_folding: show
    code_download: true
editor_options: 
  chunk_output_type: console
link-citations: true
bibliography: "thesis_supplement.bib"
---

```{r setup, include=FALSE, cache=FALSE, eval = TRUE, echo = FALSE}
library("knitr")
opts_chunk$set(
  fig.align = "center",
  fig.show = "asis",
  eval = TRUE,
  fig.width = 10,
  fig.height = 7,
  tidy = FALSE,
  message = FALSE,
  warning = FALSE,
  size = "small",
  comment = "##",
  echo = TRUE,
  results = "markup"
)
options(replace.assign = TRUE, width = 80)
```


This document accompanies my PhD thesis titled "Enhancing analysis and interpretation workflows for transcriptome data with an interactive R Bioconductor toolkit". The document will follow all the analysis and steps documented in my PhD thesis in Section 3.3.

# About the data

The data illustrated in this document is documented in detail in Section 3.3.1 of my PhD thesis. 

The datasets shown is an RNA-seq dataset, available at the Gene Expression Omnibus under the accession code [GSE130842](https://www.ncbi.xyz/geo/query/acc.cgi?acc=GSE130842).

The data represents a mouse data set of 56 different samples isolated from various murine tissues. In this analysis, I will focus in the Klrg1-negative Nfil3(GFP)-negative Tregs and Klrg1-positive Nfil3(GFP)-positive Tregs samples as discussed with the original authors of the manuscript [@Delacher2020]. To analyse the data, the count data was downloaded from the Gene Expression Omnibus (https://www.ncbi.xyz/geo/query/acc.cgi?acc=GSE130842). The count data can be found in file "GSE130842_Count_table_Delacher_et_al_2019.xlsx". Additionally, a metadata file was set up, containing the sample names, conditions and replicate numbers following the information of the GEO entry. This is the file named "GSE130842_Count_table_Delacher_et_al_2019.csv"

The workflow shown in this document will follow the steps described in our manuscript "Interactive and Reproducible Workflows for Exploring and Modeling RNA-seq Data with pcaExplorer, Ideal, and GeneTonic" [@Ludt2022].

# Loading required packages

First, load the packages required to perform all the analytic steps presented in this document.

```{r loadLibraries, results='hide'}
library("DESeq2")
library("topGO")
library("pcaExplorer")
library("ideal")
library("GeneTonic")
library("apeglm")
library("dplyr")
library("readxl")
library("GeDi")
library("org.Mm.eg.db")
library("utils")
library("ComplexHeatmap")
```

# Data processing

First, the data will be preprocessed and saved as an `DESeqDataSet` object, as described in Section 3.3.1 of my thesis.

```{r create_dds}
# Read the gene expression count data from an Excel file
# The Excel file contains the raw count table for RNA-seq data
data <- readxl::read_excel("GSE130842_Count_table_Delacher_et_al_2019.xlsx")

# Extract the gene names from the first column of the dataset
gene_names <- data$ID  # 'ID' column contains gene names

# Convert the remaining columns (gene counts) to a matrix
# Skip the first column which contains gene names
data <- as.matrix(data[, -1])

# Assign gene names as row names to the count matrix
rownames(data) <- gene_names

# Subset the data for specific columns (samples)
# Columns 33:36 and 41:44 represent selected samples for analysis
data <- data[, c(33:36, 41:44)]

# Read the metadata file that contains information about the samples
# Metadata contains columns describing conditions and replicates
metadata <- utils::read.csv("GSE130842_Metadata.csv") 

# Subset relevant columns from the metadata (conditions and replicate number)
metadata <- metadata[, c(2:3)]

# Create a DESeq2 dataset object from the count matrix and metadata
# This dataset will be used for differential expression analysis
# The design formula (~condition) specifies that the analysis should model the 'condition' variable
dds <- DESeqDataSetFromMatrix(countData = data, 
                              colData = metadata,
                              design = ~condition)

# Estimate the size factors for normalization of the data
# Size factors are used to normalize the sequencing depth across samples
dds <- estimateSizeFactors(dds)
```

# Exploratory Data Analysis using pcaExplorer 


```{r annodf}
# Retrieve gene annotation using the OrgDb database for *Mus musculus* (mouse)
# The annotation is matched using the "ENSEMBL" identifier.
anno_df <- pcaExplorer::get_annotation_orgdb(dds, "org.Mm.eg.db", "ENSEMBL")
```


```{r pcaExplorer, eval = F}
# Launch the PCAExplorer application to interactively explore principal component analysis (PCA) results.
# The function `pcaExplorer()` is called with the following inputs:
# - dds: A DESeq2 dataset object containing count data and experimental metadata
# - annotation: The annotation data frame (anno_df) containing gene annotations for better interpretation
# This opens a Shiny app that allows for interactive exploration of PCA and downstream analyses.
pcaExplorer(dds = dds, annotation = anno_df)
```


# Differential Gene Expression Analysis using ideal and GeneTonic


```{r de-ideal, eval = F}
# Launches the iDEAL Shiny app for interactive DE analysis
# - dds_obj: DESeq2 dataset object used for differential expression analysis
# - annotation_obj: Annotation object containing gene annotations (from `get_annotation_orgdb`)
# The `ideal()` function opens the interactive DE analysis tool that allows for visualization, interpretation, and exploration of DE results.
ideal(dds_obj = dds, annotation_obj = anno_df)
```



```{r de-GeneTonic}
# Reading in the differential expression (DE) gene results from a pre-generated CSV file
# This file contains the DE genes and their associated statistics
de_genes <- read.csv("table_DE_results_ideal.csv")

# Converting the data into a DESeqResults object, which stores DE analysis results
# - res_de: Contains the DE genes and their statistics for downstream analysis
res_de <- DESeqResults(de_genes)
rownames(res_de) <- res_de$X  # Assign rownames for easy indexing later
colnames(res_de)[colnames(res_de) == "symbol"] <- "SYMBOL"

# Reading the functional enrichment results from a CSV file (TopGO results)
# Limiting the results to the top 500 enriched terms for further processing
topGOResults <- read.csv("table_Functional_enrichment_Results.csv")
topGOResults <- topGOResults[c(1:500),]

# This function processes the TopGO results to ensure the format is compatible
# with downstream analysis functions in `GeneTonic`.
# `shake_topGOtableResult` modifies or reorders the table as needed.
topGOResults <- shake_topGOtableResult(topGOResults)

# Aggregating scores for the gene sets and the DE genes, linking DE results with functional enrichment.
# The `get_aggrscores` function calculates aggregated enrichment scores by combining the topGO results
# and DE results (res_de) and integrating gene annotations from the annotation object (anno_df).
res_enrich <- get_aggrscores(topGOResults,
                             res_de,
                             anno_df)

# Creating a GeneTonicList (gtl) object, which consolidates all required input data for `GeneTonic`:
# - dds: DESeq2 dataset object
# - res_de: Differential expression results object
# - res_enrich: Functional enrichment scores calculated from `get_aggrscores`
# - anno_df: Gene annotation information
# The gtl object is necessary for launching the `GeneTonic()` app.
gtl <- GeneTonicList(dds, 
                     res_de, 
                     res_enrich, 
                     anno_df)
```

```{r LaunchGeneTonic, eval = F}
# Launch the `GeneTonic()` Shiny app, which provides an interactive platform for 
# exploring and visualizing the results of differential expression and functional enrichment analysis.
GeneTonic(gtl = gtl)
```


# Functional Enrichment Result Interpretation using GeDi


```{r GeDi, eval = F}
GeDi::GeDi(gtl = gtl)
```


# Figure Generation

This part will document the code for some of the figures included in my thesis. 

```{r}
# Extract the gene sets from the 'gtl' object, specifically from the enrichment results
genesets <- gtl$res_enrich

# Rename the columns in the 'genesets' data frame so that it 
# can be used directly in `GeDi`
names(genesets)[names(genesets) == "gs_id"] <- "Genesets"
names(genesets)[names(genesets) == "gs_genes"] <- "Genes"
names(genesets)[names(genesets) == "gs_description"] <- "Term"

# Prepare the gene sets for further analysis by extracting and formatting the gene information
genes <- prepareGenesetData(genesets)

# Apply a filter to exclude gene sets that have 200 or more genes
filter <- sapply(genes, function(x) length(x) >= 200)

# Remove the filtered out, large gene sets from the 'genesets' data frame
genesets <- genesets[!filter, ]

# Prepare the filtered gene sets for further analysis by reapplying the data preparation function
genes <- prepareGenesetData(genesets)
```


## Dendrogram Example of Figure 8 and Network Example of Figure 9

```{r}
# Create a copy of the 'genesets' data frame to use as example data for further analysis
example_data <- genesets

# Filter the 'example_data' to include only specific gene sets, identified by their GO terms
example_data <-
  example_data[example_data$Genesets %in% c("GO:0051988", "GO:0051987", "GO:0051315", "GO:0007094", "GO:1901970", "GO:1905820", "GO:0051984", "GO:0090267", "GO:0051255",
 "GO:1902412", "GO:0051231"),]

# Prepare the filtered gene sets for further analysis by extracting the gene information
example_genes <- prepareGenesetData(example_data)

# Calculate the Jaccard distance scores for the selected gene sets
jaccard_scores <- getJaccardMatrix(example_genes)

# Set the row and column names of the distance matrix to be the names of the gene sets
rownames(jaccard_scores) <- colnames(jaccard_scores) <- example_data$Genesets

# Generate a dendrogram 
d <- distanceDendro(jaccard_scores)

# Increase the text size of the abscissa labels for better readability and adjust the line width
d <- d + 
  theme(axis.text.x = element_text(size = 10)) +  
  geom_path(linewidth = 5)  

# Display the customized dendrogram plot
d

# Build a graph object from the adjacency matrix derived from the Jaccard scores,
# using a threshold of 0.67 to determine similarity between gene sets
g <- buildGraph(getAdjacencyMatrix(jaccard_scores, 0.67))

# Use 'visNetwork' to visualize the graph,
# set node color to blue and node border and edge color to black
visNetwork::visIgraph(g) %>%
  visNodes(color = list(
            background = "#0092AC",
            border = "#545454" ), 
           font = list(size = 20)) %>% 
  visEdges(width = 3) 
```


## Graph Network Examples of Figure 10

```{r}
# Create a copy of the 'genesets' data to be used for further analysis and prepare data
example_data <- genesets
example_genes <- prepareGenesetData(example_data)

# Calculate the Jaccard distance matrix for the gene sets
jaccard_scores <- getJaccardMatrix(example_genes)

# Set the row and column names of the Jaccard distance matrix to be the names of the gene sets
rownames(jaccard_scores) <- colnames(jaccard_scores) <- example_data$Genesets

# Perform Louvain clustering on the Jaccard distance matrix with a threshold of 0.4
louvain <- louvainClustering(jaccard_scores, 0.4)

# Perform Fuzzy clustering on the gene sets 
# Seed clusters are identified with thresholds 0.65 and 0.3, and the final clustering is done with a threshold of 0.5
fuzzy <- fuzzyClustering(seedFinding(jaccard_scores, 0.65, 0.3), 0.5)

# Build a graph object for the Louvain and Fuzzy clustering results
g_Louvain <- buildClusterGraph(louvain, 
                               example_data,
                               example_data$Genesets,
                               color_by = "Cluster")

g_Fuzzy <- buildClusterGraph(fuzzy, 
                             example_data,
                             example_data$Genesets,
                             color_by = "Cluster")

# Visualize the Louvain and Fuzzy clustering graph 
visNetwork::visIgraph(g_Louvain) %>% 
  visNodes(color = list(border = "#545454")) %>% 
  visEdges(color = list(border = "#545454"), width = 10)

visNetwork::visIgraph(g_Fuzzy) %>% 
  visNodes(color = list(border = "#545454")) %>% 
  visEdges(color = list(border = "#545454"), width = 10) 
```


## Comparison of various Alpha paramters of Figure XX

```{r comparisonHeatmaps}
# Filter out gene sets that have fewer than 10 associated genes
filter <- sapply(genes, function(x) length(x) >= 10)
genesets_small <- genesets[!filter, ]  
genes_small <- prepareGenesetData(genesets_small) 

# Retrieve PPI information for the data 
string_db <- getStringDB(as.numeric(getId("Mus musculus")))
anno_df <- getAnnotation(string_db)
ppi <- getPPI(genes_small, string_db, anno_df)

# Calculate the Meet-Min (MM) distances
mm <- getMeetMinMatrix(genes_small)
# Set the row and column names of the MM matrix to be the names of the gene sets
rownames(mm) <- colnames(mm) <- genesets_small$Genesets

# Create a heatmap of the MM distance matrix without plot labels
d <- distanceHeatmap(mm, plot_labels = FALSE, title = "")

# Draw the heatmap and extract the row order for consistent comparison
ht <- draw(d)
row_order <- row_order(ht)

# Calculate pMM matrices for different alpha values (0, 0.5, and 1)
pMM0 <- getpMMMatrix(genes_small, ppi, alpha = 0)   
rownames(pMM0) <- colnames(pMM0) <- genesets_small$Genesets

pMM5 <- getpMMMatrix(genes_small, ppi, alpha = 0.5)
rownames(pMM5) <- colnames(pMM5) <- genesets_small$Genesets

pMM1 <- getpMMMatrix(genes_small, ppi, alpha = 1)   
rownames(pMM1) <- colnames(pMM1) <- genesets_small$Genesets

# Create and draw a heatmap for the original MM scores, keeping row order consistent
d <- distanceHeatmap(mm[row_order, row_order], 
                     plot_labels = F,
                     cluster_rows = F,
                     cluster_columns = F,
                     title = "")
draw(d)

# Create and draw a heatmap for pMM scores with alpha = 0
d <- distanceHeatmap(pMM0[row_order, row_order],
                     plot_labels = F,
                     cluster_rows = FALSE,
                     cluster_columns = FALSE,
                     title = "")
draw(d)

# Create and draw a heatmap for pMM scores with alpha = 0.5
d <- distanceHeatmap(pMM5[row_order, row_order],
                     plot_labels = F,
                     cluster_rows = FALSE,
                     cluster_columns = FALSE,
                     title = "")
draw(d)

# Create and draw a heatmap for pMM scores with alpha = 1
d <- distanceHeatmap(pMM1[row_order, row_order],
                     plot_labels = F,
                     cluster_rows = FALSE,
                     cluster_columns = FALSE,
                     title = "")
draw(d)

```

## Word Clouds of Figure XX

```{r}
# Calculate the Gene Ontology (GO) semantic distance matrix for the gene sets
goDistances <- goDistance(genesets$Genesets, species = "org.Mm.eg.db")

# Perform fuzzy clustering on the GO distance matrix.
fuzzy_clustering <- fuzzyClustering(seedFinding(goDistances, 0.5, 0.5), 0.5)

# Extract a cluster that represent T cell-related gene sets.
# The specific cluster indices were manually determined in a running `GeDi`
tCellCluster <- unique(unlist(fuzzy_clustering[c(7, 8, 14, 17, 20, 24, 28, 30, 45, 49, 50, 58, 62, 64, 65, 70, 72, 76, 81, 85, 92, 96, 103, 105, 106, 112, 114, 121, 124)]))

# Generate a word cloud visualization for the T cell-related gene sets.
enrichmentWordcloud(example_data[tCellCluster, ])

# Extract a cluster that are related to protein membrane processes.
# Again, specific cluster indices are manually selected.
proteinMembraneCluster <- unique(unlist(fuzzy_clustering[c(5, 6, 21, 23, 35, 43, 52, 54, 57, 69, 73, 80, 88, 102, 126)]))

# Generate a word cloud visualization for the protein membrane-related gene sets.
enrichmentWordcloud(example_data[proteinMembraneCluster, ])
```

## Clustering Results of Figures XX

```{r}
# Load precomputed distance matrices for the pMM and GO distance metrics
pMMDistances <- readRDS("pMM_Distances.RDS")
goDistances <- readRDS("GODistances.RDS")

# Apply Louvain clustering algorithm to the pMM distance matrix with clustering threshold 0.5
louvainpMM <- louvainClustering(pMMDistances, 0.5)

# Build a cluster graph from the Louvain clustering results for the pMM distances
g_louvainpMM <- buildClusterGraph(louvainpMM,
                                  genesets,
                                  genesets$Genesets,
                                  color_by = "Cluster")

# Visualize the Louvain clustering graph using the `visNetwork` package
visNetwork::visIgraph(g_louvainpMM) %>% 
  visNodes(color = list(border = "#545454")) %>%
  visEdges(color = list(border = "#545454"), width = 10)

# Apply Fuzzy clustering to the pMM distance matrix and
# visualisize the results afterwards
fuzzypMM <- fuzzyClustering(seedFinding(pMMDistances, 0.5, 0.5), 0.5)

g_fuzzypMM <- buildClusterGraph(fuzzypMM,
                                genesets,
                                genesets$Genesets,
                                color_by = "Cluster")

visNetwork::visIgraph(g_fuzzypMM) %>% 
  visNodes(color = list(border = "#545454")) %>%
  visEdges(color = list(border = "#545454"), width = 5)

# Apply Louvain clustering algorithm to the GO distance matrix
# Again, visualize the results afterwards
louvainGO <- louvainClustering(goDistances, 0.5)

g_louvainGO <- buildClusterGraph(louvainGO,
                                 genesets,
                                 genesets$Genesets,
                                 color_by = "Cluster")

visNetwork::visIgraph(g_louvainGO) %>% 
  visNodes(color = list(border = "#545454")) %>%
  visEdges(color = list(border = "#545454"), width = 10)
```




# Session information {-}

```{r}
sessionInfo()
```


# Bibliography {-}
